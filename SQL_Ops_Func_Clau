SQL Skills Dictionary
With Best Practice Examples

A practical reference of operators, functions, and clauses with definitions and examples. 
Assumes a relational DB like PostgreSQL/MySQL/SQL Serverr


--- Comparison Operators --- 
          Comparison operators are how you filter your data to only see what matches your conditions.

‚Ä¢ `=` equal, `<>`/`!=` not equal, `<`, `>`, `<=`, `>=` compare scalar values. less/greater/less-or-equal/more-or-equal. 
    You use these in the WHERE part of a query to filter rows ‚Äî meaning, ‚Äúonly show me the rows where this condition is true.‚Äù
‚Ä¢ Prefer explicit ranges to ambiguous logic. 
    Ex: 
    // Instead of hire_date BETWEEN '2024-01-01' AND '2024-12-31', it‚Äôs often better to say:
      hire_date >= '2024-01-01' AND hire_date < '2025-01-01'. That way you avoid weird issues with times/dates slipping through.
‚Ä¢ Use dates with explicit bounds to keep queries SARGable (index friendly). Databases work faster if you phrase things in a way that allows them to use indexes (like the index in the back of a book). 
    That‚Äôs what ‚ÄúSARGable‚Äù means - ‚Äúmake it easy for the database to look things up.‚Äù

EX: 
// Employees hired in 2024 (inclusive bounds). ‚ÄúShow me all employees hired in the year 2024.‚Äù :
  SELECT e.employee_id, e.full_name, e.hire_date
  FROM employees AS e
  WHERE e.hire_date >= DATE '2024-01-01'
    AND e.hire_date < DATE '2025-01-01';

// Orders with high value. ‚ÄúShow me all orders where the total was at least 1000.‚Äù:
  SELECT o.order_id, o.total_amount
  FROM orders AS o
  WHERE o.total_amount >= 1000;



--- Logical Operators (AND, OR, NOT) --- 
          Logical operators are words that let you combine multiple conditions together in your query. Think of them like glue between filters.
AND ‚Üí both conditions must be true.
OR ‚Üí at least one condition must be true.
NOT ‚Üí flips the condition (true becomes false, false becomes true).
          Don‚Äôt use NOT IN with subqueries if there might be NULL values (it can behave in unexpected ways). Instead, use NOT EXISTS, which handles NULLs more safely.

‚Ä¢ Combine predicates with `AND`/`OR`. Use parentheses for clarity.
‚Ä¢ Avoid `NOT IN (subquery)` with NULLs‚Äîprefer `NOT EXISTS`.

EX:
// UK or US customers over 25. ‚ÄúShow me all customers who are either from the UK or the USA, and who are older than 25.‚Äù
  SELECT c.customer_id, c.full_name, c.country, c.age
  FROM customers AS c
  WHERE (c.country IN ('UK','USA'))
    AND c.age > 25;

So:
If someone is from France, they‚Äôre excluded.
If someone is 22 years old, they‚Äôre excluded.
If they‚Äôre from the USA and 30 years old, they‚Äôre included.



--- Filtering Helpers (IN, BETWEEN, LIKE, IS NULL) ---
            Logical operators let you build more complex ‚Äúrules‚Äù for what data you want to see ‚Äî instead of just one simple filter.

‚Ä¢ `IN` for short lists; for long lists consider a lookup table JOIN.
‚Ä¢ `BETWEEN` is inclusive; for dates prefer half‚ñ†open ranges.
‚Ä¢ Use `LIKE 'abc%'` for prefix matches; avoid leading wildcard `%abc` if you need index use.
‚Ä¢ NULL checks must use `IS NULL` / `IS NOT NULL`.

EX:
// Customers with specific tier and active account:
  SELECT c.customer_id, c.full_name
  FROM customers AS c
  WHERE c.tier IN ('Gold','Platinum')
    AND c.deactivated_at IS NULL;


--- Sorting (ORDER BY) ---
          ORDER BY lets you control the order your results appear in, whether it‚Äôs smallest-to-biggest, newest-to-oldest, or highest-to-lowest.
‚Ä¢ Default is ASC; specify direction explicitly in reports.
‚Ä¢ Order by positional columns is fragile‚Äîuse names.

EX:
// Top 10 products by revenue. ‚ÄúFind the top 10 products that made the most money.‚Äù
  
SELECT p.product_id, p.product_name, SUM(oi.quantity * oi.unit_price) AS revenue
  FROM order_items AS oi
  JOIN products AS p ON p.product_id = oi.product_id
  GROUP BY p.product_id, p.product_name
  ORDER BY revenue DESC
  LIMIT 10;

First, it calculates revenue for each product (quantity √ó price, then summed up).
Then it groups by each product so you only get one row per product.
Finally, it sorts the products from highest revenue to lowest (ORDER BY revenue DESC).
The LIMIT 10 keeps only the top 10.



--- Aggregates & Grouping (COUNT, SUM, AVG, MIN, MAX, GROUP BY, HAVING) ---
          Aggregate functions are how you summarize data.
COUNT(*) ‚Üí counts rows.
COUNT(col) ‚Üí counts only rows where col is not NULL.
SUM(col) ‚Üí adds up numbers.
AVG(col) ‚Üí calculates average.
MIN(col) / MAX(col) ‚Üí lowest / highest value.
When you want these calculations per group (like ‚Äúper department‚Äù or ‚Äúper country‚Äù), you use GROUP BY.

Every column in your SELECT must either be:
Wrapped in an aggregate function (COUNT, AVG, etc.), or
Listed in the GROUP BY.
WHERE filters individual rows before grouping (row-level filter).
HAVING filters entire groups after the summary grouping (group-level filter).

‚Ä¢ Every selected column must be aggregated or listed in GROUP BY.
‚Ä¢ Use `COUNT(*)` for row counts; `COUNT(col)` ignores NULLs.
‚Ä¢ `HAVING` filters after grouping‚Äîuse `WHERE` for pre‚ñ†aggregation filters.

EX:
// Average salary per department with headcount filter. ‚ÄúShow me each department‚Äôs average salary and number of employees, but only for active employees, and only if the department has at least 5 employees.‚Äù
  SELECT e.department_id,
        AVG(e.salary)   AS avg_salary,
        COUNT(*)        AS headcount
  FROM employees AS e
  WHERE e.active = TRUE
  GROUP BY e.department_id
  HAVING COUNT(*) >= 5;



--- De-duplication (DISTINCT) ---
          Sometimes your data has duplicates (the same value shows up multiple times).
DISTINCT tells SQL: ‚Äúonly show each unique value once.‚Äù Remove duplicates from your results.
It applies to all the columns listed in SELECT ‚Äî so if you select two columns, the combination of those two must be unique to survive.
It‚Äôs usually better to fix the query or table joins so duplicates don‚Äôt appear in the first place ‚Äî because DISTINCT can be slower on big datasets.

‚Ä¢ `DISTINCT` removes duplicate rows across the selected columns.
‚Ä¢ Prefer modeling/joins that avoid duplicates; use DISTINCT as a last resort on heavy queries.

EX:
// Distinct countries with active customers. ‚ÄúList each country once where there are active customers, sorted alphabetically.‚Äù
  SELECT DISTINCT c.country
  FROM customers AS c
  WHERE c.deactivated_at IS NULL
  ORDER BY c.country;

Without DISTINCT, result = UK, USA, UK
With DISTINCT, result = UK, USA



--- Scalar Functions (text & numeric) ---
‚Ä¢ `UPPER`, `LOWER`, `TRIM`, `REPLACE`, `LENGTH`, `ROUND` for transformations.
Common ones:
UPPER(text) ‚Üí make everything uppercase.
LOWER(text) ‚Üí make everything lowercase.
TRIM(text) ‚Üí remove spaces at the start and end.
REPLACE(text, 'old', 'new') ‚Üí swap part of a string.
LENGTH(text) ‚Üí count how many characters.
ROUND(number, decimals) ‚Üí round a number.
‚Ä¢ Avoid wrapping indexed columns in functions in WHERE‚Äîtransform the parameter instead. It makes the database ignore indexes (like ripping the index out of a book).
Instead, transform the search value (parameter) before comparing.

EX:
// Clean and standardize email for comparison (transform parameter). ‚ÄúFind the user whose email matches the input, ignoring spaces and case.‚Äù 
  -- Good: transform the search value, not the column
  SELECT u.user_id, u.email
  FROM users AS u
  WHERE u.email = LOWER(TRIM(:email_input));

Scalar functions = mini transformers for text/numbers.
Use them carefully in WHERE so the database stays fast.



--- Date/Time Functions (NOW/GETDATE, DATEADD, DATEDIFF) ---
          Databases give you built-in functions for working with dates and times.
NOW() or GETDATE() ‚Üí the current date and time.
DATEADD() ‚Üí add a chunk of time (days, months, years) to a date.
DATEDIFF() ‚Üí find the difference between two dates (in days, months, years, etc.).
Store in UTC: Always keep your raw timestamps in UTC, then convert to local timezone when showing them to users. (Avoids daylight savings nightmares üôÉ).
Half-open ranges: Write ranges like >= start AND < next_start instead of BETWEEN start AND end ‚Äî this avoids overlap and off-by-one errors.

‚Ä¢ Use UTC in storage when possible; convert in presentation layer.
‚Ä¢ Use half-open ranges for periods (>= start AND < next_period_start).

EX:
// Orders placed in the last 7 days (rolling window). ‚ÄúShow me all orders placed in the last 7 days, most recent first.‚Äù
  SELECT o.order_id, o.placed_at
  FROM orders AS o
  WHERE o.placed_at >= NOW() - INTERVAL '7 days'
  ORDER BY o.placed_at DESC;

So,
NOW() = right now.
NOW() - INTERVAL '7 days' = 7 days ago from right now.
The WHERE filter keeps only orders newer than that.
ORDER BY o.placed_at DESC = newest at the top.
Date/time functions let you ask time-based questions like ‚Äúlast week,‚Äù ‚Äúnext month,‚Äù or ‚Äúhow many days old is this record?‚Äù



--- Joins (INNER, LEFT, RIGHT, FULL) ---
          When your data is spread across different tables, a JOIN lets you connect them. Think of it as saying: ‚ÄúShow me information from both tables where these things match.‚Äù
Types of joins:
INNER JOIN ‚Üí Only rows that match in both tables.
LEFT JOIN ‚Üí All rows from the left table, plus matches from the right. If no match, you‚Äôll see NULLs.
RIGHT JOIN ‚Üí Opposite of LEFT (rarely used in practice ‚Äî you can flip tables instead).
FULL JOIN ‚Üí All rows from both tables, matched where possible, NULLs where not.

‚Ä¢ Always join on keys; qualify columns with table aliases.
‚Ä¢ Prefer `INNER JOIN` for required matches; `LEFT JOIN` when the right side is optional.

EX:
// Customers and their latest order (LEFT JOIN because some may have none) ‚ÄúShow me all customers and their most recent order, if they have one.‚Äù
  WITH latest AS (
   SELECT o.customer_id,
   MAX(o.order_id) AS last_order_id
   FROM orders AS o
   GROUP BY o.customer_id
  )
  SELECT c.customer_id, c.full_name, o.order_id, o.total_amount
  FROM customers AS c
  LEFT JOIN latest AS l ON l.customer_id = c.customer_id
  LEFT JOIN orders AS o ON o.order_id = l.last_order_id;

So,
The latest CTE finds the highest order_id (latest order) for each customer.
The first LEFT JOIN connects each customer to their latest order (if it exists).
The second LEFT JOIN pulls in details of that latest order (amount, etc.).
If a customer never placed an order ‚Üí they still appear in the list, but order info will be NULL.

INNER JOIN = show only people who have matching records.
LEFT JOIN = show everyone from the left table, even if they don‚Äôt match on the right.



--- Views ---
          A view is like saving a query as a ‚Äúvirtual table.‚Äù
Instead of writing the same SELECT statement over and over, you create a view once, and then you can query it as if it were a table.
Views don‚Äôt actually store the data (by default) ‚Äî they just store the logic of the query. Every time you use the view, the database runs that saved query behind the scenes.
Keep views simple so the database can still use indexes efficiently. Note: Views are usually read-only unless your database supports special rules for updating through them.

‚Ä¢ Views encapsulate logic and improve reuse; keep them simple and index-friendly.
‚Ä¢ Treat views as read-only unless you understand updatability rules in your DBMS.

EX:
// Create and use a view for active premium customers, This creates a view called v_active_premium_customers. It contains only customers who are active and have a Premium tier.
  CREATE VIEW v_active_premium_customers AS
  SELECT c.customer_id, c.full_name, c.country
  FROM customers AS c
  WHERE c.deactivated_at IS NULL
   AND c.tier = 'Premium';

// Usage. ‚ÄúFrom my saved view of active Premium customers, show me just the ones in the UK.‚Äù
  SELECT * FROM v_active_premium_customers WHERE country = 'UK';

So,
A view = a reusable query you can treat like a table.
Great for readability and consistency, especially in reporting.



--- Subqueries & EXISTS ---
          A subquery is just a query inside another query.
You can use it:
In the WHERE clause (to check conditions).
In the FROM clause (as a temporary table).
In the SELECT clause (to return a calculated value).
          
          EXISTS checks whether the subquery returns at least one row.
It‚Äôs like asking: ‚ÄúDoes this thing exist for this row? Yes or no.‚Äù
It‚Äôs efficient because it stops as soon as it finds one match (short-circuit).
It also handles NULLs safely, unlike NOT IN.

‚Ä¢ Use `EXISTS` for semi-joins; it short-circuits and handles NULLs well.
‚Ä¢ Correlate on keys; avoid `SELECT *` in subqueries (it‚Äôs ignored, but be explicit).

EX:
// Customers who have placed at least one order (EXISTS). ‚ÄúShow me all customers who have placed at least one order.‚Äù
  SELECT c.customer_id, c.full_name
  FROM customers AS c
  WHERE EXISTS (
     SELECT 1
     FROM orders AS o
     WHERE o.customer_id = c.customer_id
  );

So,
Look at each customer.
For that customer, run the subquery ‚Üí ‚ÄúIs there an order with this same customer_id?‚Äù
If yes ‚Üí include the customer in the result.
If no ‚Üí leave them out.

Subquery = a query inside another.
EXISTS = a yes/no check to see if related rows exist.



--- Data Modification (INSERT, UPDATE, DELETE) ---
                    These are the commands to change data in your tables:
INSERT ‚Üí add new rows.
UPDATE ‚Üí change existing rows.
DELETE ‚Üí remove rows.
When inserting, always list the columns you‚Äôre filling ‚Üí safer if the table structure changes.
For updates/deletes:
Preview first with a SELECT to make sure you‚Äôre targeting the right rows.
Always include a WHERE clause (otherwise you‚Äôll update/delete everything üò±).
When making multiple changes that belong together, wrap them in a transaction (BEGIN ‚Ä¶ COMMIT). If something goes wrong, you can roll back.

‚Ä¢ Always specify column lists in INSERT.
‚Ä¢ Wrap multi-statement changes in transactions.
‚Ä¢ Always include a precise WHERE in UPDATE/DELETE; preview the target rows first.

EX:
// Insert with explicit columns. ‚ÄúAdd a new department with the given ID and name.‚Äù
  INSERT INTO departments (department_id, department_name)
  VALUES (:id, :name);

// Safe update (preview first), then apply within a transaction. 
-- Preview
  SELECT e.employee_id, e.salary
  FROM employees AS e
  WHERE e.department_id = :dept_id;
-- Apply
  BEGIN TRANSACTION;
  UPDATE employees
  SET salary = salary * 1.05
  WHERE department_id = :dept_id;
  COMMIT;

So,
First, preview ‚Üí ‚ÄúWhich employees are in this department?‚Äù
Then apply the raise ‚Üí ‚ÄúGive everyone in that department a 5% salary bump.‚Äù
Use a transaction ‚Üí if something fails, you can undo it.

// Delete orphaned child rows with referential awareness. ‚ÄúDelete order items that no longer have a matching order.‚Äù
  DELETE FROM order_items AS oi
  WHERE NOT EXISTS (
    SELECT 1 FROM orders AS o WHERE o.order_id = oi.order_id
  );

This, prevents ‚Äúorphan‚Äù records that don‚Äôt belong to anything.

INSERT = add new data.
UPDATE = change existing data (careful with WHERE).
DELETE = remove data (careful with WHERE).
Transactions = safety net for grouped changes.



--- Constraints (PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL, CHECK, DEFAULT) ---
‚Ä¢ Define constraints in DDL to enforce data integrity at the database level.
‚Ä¢ Name constraints for clarity (DBA‚ñ†friendly).

EX:
// Table with well-named constraints:
  CREATE TABLE users (
   user_id BIGINT PRIMARY KEY,
   email VARCHAR(255) NOT NULL CONSTRAINT uq_users_email UNIQUE,
   full_name VARCHAR(200) NOT NULL,
   status VARCHAR(20) NOT NULL DEFAULT 'active',
   created_at TIMESTAMP NOT NULL DEFAULT NOW(),
   CONSTRAINT ck_users_status CHECK (status IN ('active','inactive','blocked'))
  );

Never run an UPDATE or DELETE without a WHERE clause.
Group risky changes in a transaction so you can roll them back if needed.
Avoid orphaned or unintended deletions. Use EXISTS or NOT EXISTS for safety.
If you can‚Äôt explain exactly which rows will be affected, don‚Äôt run the query yet.



--- Transactions (BEGIN / COMMIT / ROLLBACK) ---
          A transaction is like wrapping multiple changes into one bundle:
Either all of them succeed together, or none of them happen at all.
If something goes wrong halfway, you can ROLLBACK (undo).
If everything looks good, you COMMIT (save permanently).
Keep them short, because while a transaction is open, the database may lock rows/tables ‚Üí which can slow down other users.

‚Ä¢ Group related changes; handle errors by rolling back.
‚Ä¢ Keep transactions short to minimize locking.

EX:
// Transfer funds pattern. ‚ÄúMove money from one account to another safely.‚Äù
  BEGIN TRANSACTION;
  UPDATE accounts SET balance = balance - :amount WHERE account_id = :from_id;
  UPDATE accounts SET balance = balance + :amount WHERE account_id = :to_id;
-- Optional: check invariant
-- SELECT ... ensure balances are non-negative, etc.
COMMIT;
/* If any step fails, issue ROLLBACK */

So,
First, subtract from the sender.
Then, add to the recipient.
If either step fails, roll back so no money is lost or duplicated.
If both succeed, commit the transaction to make it permanent.

BEGIN ‚Üí start a safe zone.
COMMIT ‚Üí save everything.
ROLLBACK ‚Üí undo everything.



--- Control Flow (CASE, IF, loops) ---
          SQL isn‚Äôt a programming language in the same way Python or Java are ‚Äî but it does let you add conditional logic to queries.
CASE ‚Üí like an ‚Äúif/else‚Äù statement inside SQL. You can create new columns or change output depending on conditions.
IF or loops ‚Üí not standard SQL. They exist only in certain databases (e.g., MySQL stored procedures, T-SQL). You usually won‚Äôt use them in everyday SELECTs.

‚Ä¢ `CASE` for computed columns inside SELECT.
‚Ä¢ Use procedural IF/loops only in stored procedures where supported.


EX:
// Bucket salaries using CASE. ‚ÄúFor each employee, show their salary band."
  SELECT e.employee_id,
         CASE
         WHEN e.salary >= 80000 THEN 'High'
         WHEN e.salary >= 40000 THEN 'Medium'
         ELSE 'Low'
     END AS salary_band
  FROM employees AS e;

So,
High if salary is ‚â• 80k
Medium if salary is ‚â• 40k
Low otherwise.‚Äù

result may look likie:
employee_id	salary_band
1           	Medium
2	          High
3	          Low

CASE = conditional logic inside queries.
Use it to categorize or bucket values without changing the data itself.



--- General Best Practices ---
‚Ä¢ Prefer explicit column lists; avoid `SELECT *`.
‚Ä¢ Use short, meaningful table aliases and qualify columns.
‚Ä¢ Keep predicates SARGable (avoid wrapping indexed columns in functions).
‚Ä¢ Use parameterized queries from applications to prevent SQL injection.
‚Ä¢ Consistent naming: snake_case for identifiers; singular table names are common in OLTP.

          Query Structure & Readability
Format queries clearly: uppercase for keywords (SELECT, WHERE), line breaks for clauses ‚Üí easier to read and debug.
Comment complex queries: explain why a tricky join or filter exists. Future you (and teammates) will thank you.
Avoid deep nesting: break large queries into CTEs (WITH clauses) so they‚Äôre easier to follow.

          Performance
Limit result sets: when testing or reporting, add LIMIT/TOP to avoid dragging huge datasets unnecessarily.
Index wisely: create indexes on columns used in joins and WHERE filters, but don‚Äôt over-index (updates/inserts will slow down).
Watch for Cartesian joins: always ensure JOINs have proper ON conditions. Missing one = accidental ‚Äúevery row vs every row‚Äù explosion.

          Data Integrity
Use constraints at the schema level (PRIMARY KEY, FOREIGN KEY, CHECK, NOT NULL, UNIQUE) ‚Üí don‚Äôt rely only on application logic.
Default values: set sensible defaults in table definitions to reduce NULL chaos.
Avoid magic numbers/strings: replace with lookup tables (e.g., status_id instead of 'active'/'inactive').

          Safety
Test destructive queries on dev/staging first ‚Üí never on production.
Always backup before schema changes (ALTER, DROP).
Prefer soft deletes (mark as inactive) in business-critical tables, unless hard deletes are truly necessary.

          Portability & Maintenance
Avoid vendor-specific SQL unless required (stick to ANSI SQL where possible). Makes it easier to switch databases.
Use views for abstraction: hide complex joins/logic behind views so apps query a simple interface.
Monitor query plans: check execution plans for long-running queries to understand if indexes are being used.

Write queries for humans first, database second.
Keep them safe, maintainable, and performant.
