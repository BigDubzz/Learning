SQL Skills Dictionary
With Best Practice Examples

A practical reference of operators, functions, and clauses with definitions and examples. 
Assumes a relational DB like PostgreSQL/MySQL/SQL Serverr


--- Comparison Operators --- 
          Comparison operators are how you filter your data to only see what matches your conditions.

• `=` equal, `<>`/`!=` not equal, `<`, `>`, `<=`, `>=` compare scalar values. less/greater/less-or-equal/more-or-equal. 
    You use these in the WHERE part of a query to filter rows — meaning, “only show me the rows where this condition is true.”
• Prefer explicit ranges to ambiguous logic. 
    Ex: 
    // Instead of hire_date BETWEEN '2024-01-01' AND '2024-12-31', it’s often better to say:
      hire_date >= '2024-01-01' AND hire_date < '2025-01-01'. That way you avoid weird issues with times/dates slipping through.
• Use dates with explicit bounds to keep queries SARGable (index friendly). Databases work faster if you phrase things in a way that allows them to use indexes (like the index in the back of a book). 
    That’s what “SARGable” means - “make it easy for the database to look things up.”

EX: 
// Employees hired in 2024 (inclusive bounds). “Show me all employees hired in the year 2024.” :
  SELECT e.employee_id, e.full_name, e.hire_date
  FROM employees AS e
  WHERE e.hire_date >= DATE '2024-01-01'
    AND e.hire_date < DATE '2025-01-01';

// Orders with high value. “Show me all orders where the total was at least 1000.”:
  SELECT o.order_id, o.total_amount
  FROM orders AS o
  WHERE o.total_amount >= 1000;



--- Logical Operators (AND, OR, NOT) --- 
          Logical operators are words that let you combine multiple conditions together in your query. Think of them like glue between filters.
AND → both conditions must be true.
OR → at least one condition must be true.
NOT → flips the condition (true becomes false, false becomes true).
          Don’t use NOT IN with subqueries if there might be NULL values (it can behave in unexpected ways). Instead, use NOT EXISTS, which handles NULLs more safely.

• Combine predicates with `AND`/`OR`. Use parentheses for clarity.
• Avoid `NOT IN (subquery)` with NULLs—prefer `NOT EXISTS`.

EX:
// UK or US customers over 25. “Show me all customers who are either from the UK or the USA, and who are older than 25.”
  SELECT c.customer_id, c.full_name, c.country, c.age
  FROM customers AS c
  WHERE (c.country IN ('UK','USA'))
    AND c.age > 25;

So:
If someone is from France, they’re excluded.
If someone is 22 years old, they’re excluded.
If they’re from the USA and 30 years old, they’re included.



--- Filtering Helpers (IN, BETWEEN, LIKE, IS NULL) ---
            Logical operators let you build more complex “rules” for what data you want to see — instead of just one simple filter.

• `IN` for short lists; for long lists consider a lookup table JOIN.
• `BETWEEN` is inclusive; for dates prefer half■open ranges.
• Use `LIKE 'abc%'` for prefix matches; avoid leading wildcard `%abc` if you need index use.
• NULL checks must use `IS NULL` / `IS NOT NULL`.

EX:
// Customers with specific tier and active account:
  SELECT c.customer_id, c.full_name
  FROM customers AS c
  WHERE c.tier IN ('Gold','Platinum')
    AND c.deactivated_at IS NULL;


--- Sorting (ORDER BY) ---
          ORDER BY lets you control the order your results appear in, whether it’s smallest-to-biggest, newest-to-oldest, or highest-to-lowest.
• Default is ASC; specify direction explicitly in reports.
• Order by positional columns is fragile—use names.

EX:
// Top 10 products by revenue. “Find the top 10 products that made the most money.”
  
SELECT p.product_id, p.product_name, SUM(oi.quantity * oi.unit_price) AS revenue
  FROM order_items AS oi
  JOIN products AS p ON p.product_id = oi.product_id
  GROUP BY p.product_id, p.product_name
  ORDER BY revenue DESC
  LIMIT 10;

First, it calculates revenue for each product (quantity × price, then summed up).
Then it groups by each product so you only get one row per product.
Finally, it sorts the products from highest revenue to lowest (ORDER BY revenue DESC).
The LIMIT 10 keeps only the top 10.



--- Aggregates & Grouping (COUNT, SUM, AVG, MIN, MAX, GROUP BY, HAVING) ---
          Aggregate functions are how you summarize data.
COUNT(*) → counts rows.
COUNT(col) → counts only rows where col is not NULL.
SUM(col) → adds up numbers.
AVG(col) → calculates average.
MIN(col) / MAX(col) → lowest / highest value.
When you want these calculations per group (like “per department” or “per country”), you use GROUP BY.

Every column in your SELECT must either be:
Wrapped in an aggregate function (COUNT, AVG, etc.), or
Listed in the GROUP BY.
WHERE filters individual rows before grouping (row-level filter).
HAVING filters entire groups after the summary grouping (group-level filter).

• Every selected column must be aggregated or listed in GROUP BY.
• Use `COUNT(*)` for row counts; `COUNT(col)` ignores NULLs.
• `HAVING` filters after grouping—use `WHERE` for pre■aggregation filters.

EX:
// Average salary per department with headcount filter. “Show me each department’s average salary and number of employees, but only for active employees, and only if the department has at least 5 employees.”
  SELECT e.department_id,
        AVG(e.salary)   AS avg_salary,
        COUNT(*)        AS headcount
  FROM employees AS e
  WHERE e.active = TRUE
  GROUP BY e.department_id
  HAVING COUNT(*) >= 5;



--- De-duplication (DISTINCT) ---
          Sometimes your data has duplicates (the same value shows up multiple times).
DISTINCT tells SQL: “only show each unique value once.” Remove duplicates from your results.
It applies to all the columns listed in SELECT — so if you select two columns, the combination of those two must be unique to survive.
It’s usually better to fix the query or table joins so duplicates don’t appear in the first place — because DISTINCT can be slower on big datasets.

• `DISTINCT` removes duplicate rows across the selected columns.
• Prefer modeling/joins that avoid duplicates; use DISTINCT as a last resort on heavy queries.

EX:
// Distinct countries with active customers. “List each country once where there are active customers, sorted alphabetically.”
  SELECT DISTINCT c.country
  FROM customers AS c
  WHERE c.deactivated_at IS NULL
  ORDER BY c.country;

Without DISTINCT, result = UK, USA, UK
With DISTINCT, result = UK, USA



--- Scalar Functions (text & numeric) ---
• `UPPER`, `LOWER`, `TRIM`, `REPLACE`, `LENGTH`, `ROUND` for transformations.
Common ones:
UPPER(text) → make everything uppercase.
LOWER(text) → make everything lowercase.
TRIM(text) → remove spaces at the start and end.
REPLACE(text, 'old', 'new') → swap part of a string.
LENGTH(text) → count how many characters.
ROUND(number, decimals) → round a number.
• Avoid wrapping indexed columns in functions in WHERE—transform the parameter instead. It makes the database ignore indexes (like ripping the index out of a book).
Instead, transform the search value (parameter) before comparing.

EX:
// Clean and standardize email for comparison (transform parameter). “Find the user whose email matches the input, ignoring spaces and case.” 
  -- Good: transform the search value, not the column
  SELECT u.user_id, u.email
  FROM users AS u
  WHERE u.email = LOWER(TRIM(:email_input));

Scalar functions = mini transformers for text/numbers.
Use them carefully in WHERE so the database stays fast.



--- Date/Time Functions (NOW/GETDATE, DATEADD, DATEDIFF) ---
• Use UTC in storage when possible; convert in presentation layer.
• Use half-open ranges for periods (>= start AND < next_period_start).

EX:
// Orders placed in the last 7 days (rolling window):
  SELECT o.order_id, o.placed_at
  FROM orders AS o
  WHERE o.placed_at >= NOW() - INTERVAL '7 days'
  ORDER BY o.placed_at DESC;


--- Joins (INNER, LEFT, RIGHT, FULL) ---
• Always join on keys; qualify columns with table aliases.
• Prefer `INNER JOIN` for required matches; `LEFT JOIN` when the right side is optional.

EX:
// Customers and their latest order (LEFT JOIN because some may have none):
  WITH latest AS (
   SELECT o.customer_id,
   MAX(o.order_id) AS last_order_id
   FROM orders AS o
   GROUP BY o.customer_id
  )
  SELECT c.customer_id, c.full_name, o.order_id, o.total_amount
  FROM customers AS c
  LEFT JOIN latest AS l ON l.customer_id = c.customer_id
  LEFT JOIN orders AS o ON o.order_id = l.last_order_id;


--- Views ---
• Views encapsulate logic and improve reuse; keep them simple and index■friendly.
• Treat views as read■only unless you understand updatability rules in your DBMS.

EX:
// Create and use a view for active premium customers:
  CREATE VIEW v_active_premium_customers AS
  SELECT c.customer_id, c.full_name, c.country
  FROM customers AS c
  WHERE c.deactivated_at IS NULL
   AND c.tier = 'Premium';

// Usage
  SELECT * FROM v_active_premium_customers WHERE country = 'UK';


--- Subqueries & EXISTS ---
• Use `EXISTS` for semi-joins; it short-circuits and handles NULLs well.
• Correlate on keys; avoid `SELECT *` in subqueries (it’s ignored, but be explicit).

EX:
// Customers who have placed at least one order (EXISTS):
  SELECT c.customer_id, c.full_name
  FROM customers AS c
  WHERE EXISTS (
     SELECT 1
     FROM orders AS o
     WHERE o.customer_id = c.customer_id
  );

--- Data Modification (INSERT, UPDATE, DELETE) ---
• Always specify column lists in INSERT.
• Wrap multi■statement changes in transactions.
• Always include a precise WHERE in UPDATE/DELETE; preview the target rows first.

EX:
// Insert with explicit columns:
  INSERT INTO departments (department_id, department_name)
  VALUES (:id, :name);
// Safe update (preview first), then apply within a transaction:
-- Preview
  SELECT e.employee_id, e.salary
  FROM employees AS e
  WHERE e.department_id = :dept_id;
-- Apply
  BEGIN TRANSACTION;
  UPDATE employees
  SET salary = salary * 1.05
  WHERE department_id = :dept_id;
  COMMIT;
// Delete orphaned child rows with referential awareness:
  DELETE FROM order_items AS oi
  WHERE NOT EXISTS (
    SELECT 1 FROM orders AS o WHERE o.order_id = oi.order_id
  );


--- Constraints (PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL, CHECK, DEFAULT) ---
• Define constraints in DDL to enforce data integrity at the database level.
• Name constraints for clarity (DBA■friendly).

EX:
// Table with well-named constraints:
  CREATE TABLE users (
   user_id BIGINT PRIMARY KEY,
   email VARCHAR(255) NOT NULL CONSTRAINT uq_users_email UNIQUE,
   full_name VARCHAR(200) NOT NULL,
   status VARCHAR(20) NOT NULL DEFAULT 'active',
   created_at TIMESTAMP NOT NULL DEFAULT NOW(),
   CONSTRAINT ck_users_status CHECK (status IN ('active','inactive','blocked'))
  );


--- Transactions (BEGIN / COMMIT / ROLLBACK) ---
• Group related changes; handle errors by rolling back.
• Keep transactions short to minimize locking.

EX:
// Transfer funds pattern:
  BEGIN TRANSACTION;
  UPDATE accounts SET balance = balance - :amount WHERE account_id = :from_id;
  UPDATE accounts SET balance = balance + :amount WHERE account_id = :to_id;
-- Optional: check invariant
-- SELECT ... ensure balances are non-negative, etc.
COMMIT;
/* If any step fails, issue ROLLBACK */


--- Control Flow (CASE, IF, loops) ---
• `CASE` for computed columns inside SELECT.
• Use procedural IF/loops only in stored procedures where supported.

EX:
// Bucket salaries using CASE:
  SELECT e.employee_id,
         CASE
         WHEN e.salary >= 80000 THEN 'High'
         WHEN e.salary >= 40000 THEN 'Medium'
         ELSE 'Low'
     END AS salary_band
  FROM employees AS e;


--- General Best Practices ---
• Prefer explicit column lists; avoid `SELECT *`.
• Use short, meaningful table aliases and qualify columns.
• Keep predicates SARGable (avoid wrapping indexed columns in functions).
• Use parameterized queries from applications to prevent SQL injection.
• Consistent naming: snake_case for identifiers; singular table names are common in OLTP.
